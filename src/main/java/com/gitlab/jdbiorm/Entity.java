package com.gitlab.jdbiorm;

import javax.validation.ConstraintViolation;
import javax.validation.ConstraintViolationException;
import java.io.Serializable;
import java.util.Set;

/**
 * Allows you to fetch rows of a database table, and adds useful utility methods [save]
 * and [delete].
 *
 * Automatically will try to store/update/retrieve all non-transient fields declared by this class and all superclasses.
 * To exclude fields, either annotate them with `field:Transient` or `field:Ignore`.
 *
 * If your table has no primary key or there is other reason you don't want to use this interface, you can still use
 * the DAO methods (see [DaoOfAny] for more details); you only lose the ability to [save], [create] and [delete].
 *
 * ### Auto-generated IDs vs pre-provided IDs
 * There are generally three cases for entity ID generation:
 * * IDs generated by the database when the `INSERT` statement is executed
 * * Natural IDs, such as a NaturalPerson with ID pre-provided by the government (social security number etc).
 * * IDs created by the application, for example via [UUID.randomUUID]
 *
 * The [save] method is designed to work out-of-the-box only for the first case (IDs auto-generated by the database). In this
 * case, [save] emits `INSERT` when the ID is null, and `UPDATE` when the ID is not null.
 *
 * When the ID is pre-provided, you can only use [save] method to update a row in the database; using [save] to create a
 * row in the database will throw an exception. In order to create an
 * entity with a pre-provided ID, you need to use the [create] method:
 * ```
 * NaturalPerson(id = "12345678", name = "Albedo").create()
 * ```
 *
 * For entities with IDs created by the application you can make [save] work properly, by overriding the [create] method
 * as follows:
 * ```
 * override fun create(validate: Boolean) {
 *   id = UUID.randomUUID()
 *   super.create(validate)
 * }
 * ```
 * @param <ID> the type of the primary key. All finder methods will only accept this type of ids.
 * @author mavi
 */
public interface Entity<ID> extends Serializable {
    /**
     * The ID primary key. You can use the {@link org.jdbi.v3.core.mapper.reflect.ColumnName} annotation to change the actual db column name.
     * @return the ID primary key, may be null.
     */
    ID getId();

    /**
     * Sets the ID key.
     * @param id the ID primary key, may be null.
     */
    void setId(ID id);

    /**
     * Validates current entity. By default performs the java validation: just add {@code javax.validation}
     * annotations to entity properties.
     * <p></p>
     * Make sure to add the validation annotations to
     * fields otherwise they will be ignored.
     * <p></p>
     * You can override this method to perform additional validations on the level of the entire entity.
     * @throws javax.validation.ValidationException when validation fails.
     */
    default void validate() {
        final Set<ConstraintViolation<Entity<ID>>> violations = Jdbiorm.get().getValidator().validate(this);
        if (!violations.isEmpty()) {
            throw new ConstraintViolationException(violations);
        }
    }

    default boolean isValid() {
        try {
            validate();
            return true;
        } catch (ConstraintViolationException ex) {
            return false;
        }
    }
}
